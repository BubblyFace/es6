# let和Const命令
## let命令
    let命令所声明的变量只能在代码块中存在。
### 暂时性死区
使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。
暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
###  不允许重复声明
    let不允许在相同作用域重复声明同一个变量

## 块级作用域
es6新增了块级作用域，let所带来的结果
### ES6的块级作用域与函数声明
es5 函数不可以在块级作用域声明函数
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用
ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
! 块级作用域内部是可以访问全局变量的

>允许在块级作用域内声明函数。
>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
>同时，函数声明还会提升到所在的块级作用域的头部。

根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量
考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

`
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
`

## do 表达式
让块级作用域变成表达式，可以返回值
`
let x = do{
    let t = f();
    t * t+1;
}
`
## const命令
只读常量，一旦声明，常量的值就不可以改变，所以声明的时候必须给其赋值
1. const的作用域与let命令相同：只在声明所在的块级作用域内有效。
2. const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
3. const声明的常量，也与let一样不可重复声明。
4. 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心
    `
    const a = [];
    a.push('Hello'); // 可执行
    a.length = 0;    // 可执行
    a = ['Dave'];    // 报错
    `
5. 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
6. 对象冻结

## 顶层属性对象
ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
`
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
`
上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。
## global对象
>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
>浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。
>Node 里面，顶层对象是global，但其他环境都不支持。


