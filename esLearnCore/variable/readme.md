# 变量的解构赋值
## 数组解构
    let [a,b,c] = [1,2,3]
    let [x,y,z] = new Set(['a','b','c'])
不完全解构也是可以成功的
>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
>解构赋值允许默认值，前提位置上的值严格等于undefined

## 对象的解构赋值
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

    let {foo,bar} = {
        foo: "aaa",
        bar: "bbb"
    } 

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

类似于模式匹配

## 字符串的解构赋值

    const [a,b,c,d,e] = 'hello';

## 数值和布尔值的解构赋值
解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

## 函数参数的解构赋值

    //example
    function([x,y]){
        return x + y;
    }
    add([1,2]);//3

上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。


## 圆括号问题
解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。

由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。

但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。

### 不能使用圆括号的情况
1. 变量声明语句中，不能带有圆括号。
<code>
    //全部报错
    let [(a)] = [1];
    let {x: (c)} = {};
    let ({x: c}) = {};
    let {(x: c)} = {};
    let {(x): c} = {};
    let { o: ({ p: p }) } = { o: { p: 2 } };

</code>


2. 函数参数中，模式不能带有圆括号。
    // 报错
    function f([(z)]) { return z; }
3. 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
    <code>
    // 全部报错
    ({ p: a }) = { p: 42 };
    ([a]) = [5];

    //  报错
    [({ p: a }), { x: c }] = [{}, {} ]; 
    </code>


### 可以使用圆括号的情况
可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

    [(b)] = [3]; // 正确
    ({ p: (d) } = {}); // 正确
    [(parseInt.prop)] = [3]; // 正确


## 用途
1. 交换变量的值
2. 从函数返回多个值
3. 函数参数的定义
4. 提取json数据
5. 函数参数的默认值（避免了写这种语句“<strong>var foo = config.foo || 'default foo';</strong>”）
6. 遍历结构（<strong>for...of</strong>>）
7. 
